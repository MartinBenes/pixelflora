<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedur√°ln√≠ Gener√°tor Rostlin (Pixel Art)</title>
    <style>
        :root {
            --bg-color: #1a1a1d;
            --panel-bg: #2d2d35;
            --text-color: #e0e0e0;
            --accent: #4caf50;
            --border: #444;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Layout */
        .container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }

        .controls {
            flex: 1;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            overflow-y: auto;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .preview-area {
            flex: 2;
            background: #111;
            border-radius: 8px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* UI Elements */
        h2, h3 { margin-top: 0; color: var(--accent); }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }

        label { font-size: 0.9em; color: #aaa; }
        
        select, input[type="text"] {
            background: #222;
            border: 1px solid #555;
            color: white;
            padding: 8px;
            border-radius: 4px;
        }

        input[type="checkbox"] {
            transform: scale(1.2);
            accent-color: var(--accent);
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        button:hover { opacity: 0.9; }
        button.secondary { background: #555; }

        /* Canvas rendering */
        canvas {
            image-rendering: pixelated; /* Kl√≠ƒçov√© pro ostr√Ω pixel art */
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            background: transparent;
        }

        .canvas-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .meta-info {
            font-family: monospace;
            color: #888;
            font-size: 0.8em;
            margin-top: 10px;
            text-align: center;
        }

        #seed-display {
            font-family: monospace;
            background: #000;
            padding: 5px 10px;
            border-radius: 4px;
            color: var(--accent);
        }

    </style>
</head>
<body>

<div class="container">
    <!-- Ovl√°dac√≠ panel (Fenotyp + Seed) -->
    <div class="controls">
        <h2>Laborato≈ô</h2>
        
        <div class="control-group">
            <label for="input-seed">Seed (≈òetƒõzec nebo ƒç√≠slo)</label>
            <div style="display:flex; gap:5px;">
                <input type="text" id="input-seed" value="rostlina1" style="flex:1">
                <button class="secondary" id="btn-random-seed">üé≤</button>
            </div>
        </div>

        <h3>Genotyp (Fenotyp)</h3>
        
        <div class="control-group">
            <label>Stonek: Tvar / Tlou≈°≈•ka / Povrch</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-stem" style="flex:1">
                    <option value="straight">Rovn√Ω</option>
                    <option value="vine">Li√°na</option>
                </select>
                <select id="gene-stem-thickness" style="flex:1">
                    <option value="thin">Tenk√Ω</option>
                    <option value="thick">Tlust√Ω</option>
                </select>
                <select id="gene-stem-texture" style="flex:1">
                    <option value="smooth">Hladk√Ω</option>
                    <option value="hairy">Chlupat√Ω</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>Listy: Tvar / Velikost / Okraj</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-leaf" style="flex:1">
                    <option value="narrow">√özk√©</option>
                    <option value="wide">≈†irok√©</option>
                </select>
                <select id="gene-leaf-size" style="flex:1">
                    <option value="small">Mal√©</option>
                    <option value="medium" selected>St≈ôedn√≠</option>
                    <option value="large">Velk√©</option>
                </select>
            </div>
             <select id="gene-leaf-edge" style="margin-top:5px;">
                <option value="smooth">Hladk√Ω okraj</option>
                <option value="serrated">Zoubkovan√Ω (Pilovit√Ω)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="gene-foliage-color">Barva rostliny (Foliage)</label>
            <select id="gene-foliage-color">
                <option value="green">Zelen√° (Green)</option>
                <option value="teal">Siv√°/Modr√° (Teal)</option>
                <option value="autumn">Podzimn√≠ (Autumn)</option>
                <option value="dark">Tmav√° (Dark)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Kvƒõt: Tvar / Velikost / Vzor</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-flower-shape" style="flex:1">
                    <option value="round">Obl√©</option>
                    <option value="pointy">≈†piƒçat√©</option>
                </select>
                <select id="gene-flower-size" style="flex:1">
                    <option value="small">Mal√Ω</option>
                    <option value="medium" selected>St≈ôedn√≠</option>
                    <option value="large">Velk√Ω</option>
                </select>
            </div>
            <select id="gene-flower-pattern" style="margin-top:5px;">
                <option value="plain">Bez vzoru</option>
                <option value="stripes">Pruhy</option>
                <option value="dots">Teƒçky</option>
            </select>
        </div>

        <div class="control-group">
            <label>Barvy kvƒõtu (Prim√°rn√≠ / Sekund√°rn√≠)</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-color" style="flex:1">
                    <option value="red">ƒåerven√°</option>
                    <option value="blue">Modr√°</option>
                    <option value="purple">Fialov√°</option>
                    <option value="white">B√≠l√°</option>
                    <option value="yellow">≈Ωlut√°</option>
                </select>
                <select id="gene-color-2" style="flex:1">
                    <option value="red">ƒåerven√°</option>
                    <option value="blue">Modr√°</option>
                    <option value="purple">Fialov√°</option>
                    <option value="white">B√≠l√°</option>
                    <option value="yellow">≈Ωlut√°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label for="gene-sex">Pohlav√≠ kvƒõtu</label>
            <select id="gene-sex">
                <option value="hermaphrodite">Hermafrodit (Pest√≠k + Tyƒçinky)</option>
                <option value="female">Samiƒç√≠ (Jen Pest√≠k)</option>
                <option value="male">Samƒç√≠ (Jen Tyƒçinky)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="gene-fruit-shape">Tvar plodu</label>
            <select id="gene-fruit-shape">
                <option value="round">Kulat√Ω</option>
                <option value="oval">Ov√°ln√Ω</option>
            </select>
        </div>

        <div class="control-group">
            <label class="checkbox-row" style="margin-bottom: 5px;">
                <input type="checkbox" id="animate-toggle">
                <span style="color: var(--accent); font-weight:bold;">Animace (Idle)</span>
            </label>
        </div>

        <div class="checkbox-row">
            <label class="checkbox-row" style="flex:1">
                <input type="checkbox" id="gene-thorns">
                <span>Trnit√©</span>
            </label>
             <label class="checkbox-row" style="flex:1">
                <input type="checkbox" id="gene-fruit">
                <span>Plod√≠c√≠</span>
            </label>
        </div>

        <div class="control-group">
            <label class="checkbox-row">
                <input type="checkbox" id="gene-glow">
                <span>Bioluminiscence (Glow)</span>
            </label>
        </div>

        <button id="btn-generate">Generovat Rostlinu</button>
        <button id="btn-export" class="secondary">Kop√≠rovat Seed Kartu</button>
    </div>

    <!-- V√Ωhledov√° plocha -->
    <div class="preview-area">
        <div class="canvas-container">
            <!-- Canvas 192x288 (HD pixel art, 3x detail) -->
            <canvas id="plantCanvas" width="192" height="288" style="width: 384px; height: 576px;"></canvas>
            <div class="meta-info">
                <span id="seed-display">Seed: --</span><br>
                <span id="time-display">Render: 0ms | Frame: 0</span>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * === PALETY A KONSTANTY ===
 */
// Light source direction (normalized, from top-left)
const LIGHT_DIR = { x: -0.6, y: -0.8 };

const PALETTES = {
    foliage: {
        green:  { highlight: '#a5d64d', light: '#7cb342', main: '#558b2f', dark: '#33691e', shadow: '#1b5e20' },
        teal:   { highlight: '#b2dfdb', light: '#80cbc4', main: '#00897b', dark: '#004d40', shadow: '#00251a' },
        autumn: { highlight: '#ffe0b2', light: '#ffcc80', main: '#ef6c00', dark: '#e65100', shadow: '#bf360c' },
        dark:   { highlight: '#cfd8dc', light: '#90a4ae', main: '#546e7a', dark: '#37474f', shadow: '#263238' }
    },
    pot: {
        highlight: '#d7ccc8', light: '#a1887f', main: '#8d6e63',
        dark: '#6d4c41', shadow: '#4e342e', rim: '#bcaaa4',
        soil: '#3e2723', soilLight: '#4e342e', soilDark: '#2c1a12'
    },
    thorns: { highlight: '#6d4c41', main: '#4e342e', dark: '#3e2723' },
    fruits: [
        { highlight: '#ffab91', light: '#ff8a65', main: '#e64a19', dark: '#bf360c' },
        { highlight: '#ce93d8', light: '#ba68c8', main: '#8e24aa', dark: '#4a148c' },
        { highlight: '#ef9a9a', light: '#ef5350', main: '#c62828', dark: '#b71c1c' },
        { highlight: '#81d4fa', light: '#4fc3f7', main: '#039be5', dark: '#01579b' }
    ],
    flowers: {
        red:    { highlight: '#ffcdd2', light: '#ef9a9a', main: '#e53935', dark: '#c62828', shadow: '#b71c1c' },
        blue:   { highlight: '#bbdefb', light: '#90caf9', main: '#1e88e5', dark: '#1565c0', shadow: '#0d47a1' },
        purple: { highlight: '#e1bee7', light: '#ce93d8', main: '#8e24aa', dark: '#6a1b9a', shadow: '#4a148c' },
        white:  { highlight: '#ffffff', light: '#f5f5f5', main: '#e0e0e0', dark: '#bdbdbd', shadow: '#9e9e9e' },
        yellow: { highlight: '#fff9c4', light: '#fff176', main: '#fdd835', dark: '#f9a825', shadow: '#f57f17' }
    },
    stamens: { stem: '#fff9c4', tip: '#f57f17', tipLight: '#ff9800' },
    sepals: { highlight: '#81c784', light: '#66bb6a', main: '#388e3c', dark: '#2e7d32' },
    glow: { bright: '#ccff90', mid: '#b2ff59', dim: '#76ff03' }
};

/**
 * === PRNG (Pseudo-Random Number Generator) ===
 */
class Random {
    constructor(seedStr) {
        // Hashov√°n√≠ stringu na ƒç√≠slo
        let h = 2166136261 >>> 0;
        for (let i = 0; i < seedStr.length; i++) {
            h = Math.imul(h ^ seedStr.charCodeAt(i), 16777619);
        }
        this.state = h;
    }

    // Vrac√≠ float 0.0 a≈æ 1.0
    next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }

    // Vrac√≠ integer min (vƒçetnƒõ) a≈æ max (vƒçetnƒõ)
    range(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
    
    // Vrac√≠ float min a≈æ max
    float(min, max) {
        return this.next() * (max - min) + min;
    }

    // Pravda/Nepravda s pravdƒõpodobnost√≠ p
    bool(p = 0.5) {
        return this.next() < p;
    }
    
    // N√°hodn√° volba z pole
    pick(array) {
        return array[Math.floor(this.next() * array.length)];
    }
}

/**
 * === DRAWING ENGINE (HD Pixel Art) ===
 */
const DETAIL_FACTOR = 3;
const s = (value) => Math.max(1, Math.round(value * DETAIL_FACTOR));
const CTX_WIDTH = s(64);   // 192
const CTX_HEIGHT = s(96);  // 288

function drawPixel(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.round(x), Math.round(y), 1, 1);
}

function drawLine(ctx, x0, y0, x1, y1, color) {
    x0 = Math.round(x0); y0 = Math.round(y0);
    x1 = Math.round(x1); y1 = Math.round(y1);
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = (x0 < x1) ? 1 : -1;
    const sy = (y0 < y1) ? 1 : -1;
    let err = dx - dy;
    ctx.fillStyle = color;
    while (true) {
        ctx.fillRect(x0, y0, 1, 1);
        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x0 += sx; }
        if (e2 < dx) { err += dx; y0 += sy; }
    }
}

function drawCircle(ctx, xc, yc, r, color) {
    xc = Math.round(xc); yc = Math.round(yc); r = Math.floor(r);
    ctx.fillStyle = color;
    for (let y = -r; y <= r; y++) {
        for (let x = -r; x <= r; x++) {
            if (x * x + y * y <= r * r) ctx.fillRect(xc + x, yc + y, 1, 1);
        }
    }
}

// Shaded circle with directional lighting
function drawShadedCircle(ctx, xc, yc, r, palette) {
    xc = Math.round(xc); yc = Math.round(yc); r = Math.floor(r);
    for (let y = -r; y <= r; y++) {
        for (let x = -r; x <= r; x++) {
            if (x * x + y * y > r * r) continue;
            const nx = x / r, ny = y / r;
            const dot = -(nx * LIGHT_DIR.x + ny * LIGHT_DIR.y);
            const d = (Math.abs(xc + x) + Math.abs(yc + y)) % 2 === 0;
            let color = shadeColor(dot, d, palette);
            ctx.fillStyle = color;
            ctx.fillRect(xc + x, yc + y, 1, 1);
        }
    }
}

// Blend two hex colors: blendHex('#ff0000', '#0000ff', 0.3) => 30% toward blue
function blendHex(base, overlay, t) {
    const b = parseInt(base.slice(1), 16);
    const o = parseInt(overlay.slice(1), 16);
    const r = Math.round(((b >> 16) & 0xff) + (((o >> 16) & 0xff) - ((b >> 16) & 0xff)) * t);
    const g = Math.round(((b >> 8) & 0xff) + (((o >> 8) & 0xff) - ((b >> 8) & 0xff)) * t);
    const bl = Math.round((b & 0xff) + ((o & 0xff) - (b & 0xff)) * t);
    return `#${((r << 16) | (g << 8) | bl).toString(16).padStart(6, '0')}`;
}

// Shade helper: maps light dot product to palette color with subtle blending
function shadeColor(dot, d, palette) {
    if (dot > 0.5 && d) return blendHex(palette.main, palette.light, 0.35);
    if (dot < -0.5 && d) return blendHex(palette.main, palette.dark, 0.35);
    return palette.main;
}

// Shaded rotated ellipse with directional lighting, serration & patterns
function drawShadedEllipse(ctx, xc, yc, rx, ry, angle, palette, options = {}) {
    const { isSerrated = false, pattern = 'plain', patternColor = null, outline = false } = options;
    const maxR = Math.max(rx, ry) + 1;
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    for (let x = -maxR; x <= maxR; x++) {
        for (let y = -maxR; y <= maxR; y++) {
            const dx = x * cosA + y * sinA;
            const dy = y * cosA - x * sinA;
            let dist = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry);
            if (isSerrated) {
                const theta = Math.atan2(dy, dx);
                if (dist > 1.0 - 0.18 * Math.abs(Math.sin(theta * 7))) continue;
            } else {
                if (dist > 1) continue;
            }
            if (outline && dist > 0.85) {
                ctx.fillStyle = palette.shadow || palette.dark;
                ctx.fillRect(Math.round(xc + x), Math.round(yc + y), 1, 1);
                continue;
            }
            const nx = dx / rx, ny = dy / ry;
            const dot = -(nx * LIGHT_DIR.x + ny * LIGHT_DIR.y);
            const d = (Math.abs(Math.round(xc + x)) + Math.abs(Math.round(yc + y))) % 2 === 0;
            let color = shadeColor(dot, d, palette);
            if (pattern === 'stripes' && Math.abs(Math.round(dx)) % 8 < 2)
                color = patternColor || palette.light;
            else if (pattern === 'dots' && Math.round(dx * dx + dy * dy) % 11 === 0)
                color = patternColor || palette.light;
            ctx.fillStyle = color;
            ctx.fillRect(Math.round(xc + x), Math.round(yc + y), 1, 1);
        }
    }
}

// Shaded rhombus (pointed petals/leaves)
function drawShadedRhombus(ctx, xc, yc, rx, ry, angle, palette, options = {}) {
    const { pattern = 'plain', patternColor = null } = options;
    const maxR = Math.max(rx, ry) + 1;
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    for (let x = -maxR; x <= maxR; x++) {
        for (let y = -maxR; y <= maxR; y++) {
            const dx = x * cosA + y * sinA;
            const dy = y * cosA - x * sinA;
            if (Math.abs(dx / rx) + Math.abs(dy / ry) > 1) continue;
            const nx = dx / rx, ny = dy / ry;
            const dot = -(nx * LIGHT_DIR.x + ny * LIGHT_DIR.y);
            const d = (Math.abs(Math.round(xc + x)) + Math.abs(Math.round(yc + y))) % 2 === 0;
            let color = shadeColor(dot, d, palette);
            if (pattern === 'stripes' && Math.abs(Math.round(dx)) % 8 < 2)
                color = patternColor || palette.light;
            else if (pattern === 'dots' && Math.round(dx * dx + dy * dy) % 11 === 0)
                color = patternColor || palette.light;
            ctx.fillStyle = color;
            ctx.fillRect(Math.round(xc + x), Math.round(yc + y), 1, 1);
        }
    }
}

/**
 * === LOGIKA GENER√ÅTORU ===
 */

function generatePlant(canvas, phenotype, seedStr, frame = 0) {
    const startTime = performance.now();
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CTX_WIDTH, CTX_HEIGHT);

    const plantData = { stemNodes: [], topX: 0, topY: 0 };
    const windPattern = [0, 1, 0, -1];
    const windForceInt = windPattern[frame % 4];

    drawStem(ctx, new Random(seedStr + "_stem"), phenotype, plantData, windForceInt);
    drawPot(ctx, new Random(seedStr + "_pot"));
    if (phenotype.stem === 'vine')
        drawTendrils(ctx, new Random(seedStr + "_tendrils"), phenotype, plantData);
    drawLeaves(ctx, new Random(seedStr + "_leaves"), phenotype, plantData, windForceInt);
    if (phenotype.thorns)
        drawThorns(ctx, new Random(seedStr + "_thorns"), plantData);
    if (phenotype.fruit)
        drawFruits(ctx, new Random(seedStr + "_fruit"), phenotype, plantData);
    drawFlower(ctx, new Random(seedStr + "_flower"), phenotype, plantData, windForceInt);
    if (phenotype.glow)
        drawGlow(ctx, new Random(seedStr + "_glow"), plantData);

    return (performance.now() - startTime).toFixed(2);
}

// --- VRSTVA 1: KVƒöTIN√Åƒå (Shaded terracotta) ---
function drawPot(ctx, rng) {
    const cx = CTX_WIDTH / 2;
    const potHeight = s(12);
    const yBottom = CTX_HEIGHT - s(3);
    const yTop = yBottom - potHeight;
    const halfTop = s(18) / 2;
    const halfBot = s(12) / 2;
    const rimH = s(2);
    const rimW = halfTop + s(1);

    // Main body
    ctx.fillStyle = PALETTES.pot.main;
    for (let i = 0; i <= potHeight; i++) {
        const t = i / potHeight;
        const hw = halfTop - (t * (halfTop - halfBot));
        for (let dx = -hw; dx < hw; dx++) {
            ctx.fillRect(Math.round(cx + dx), yTop + i, 1, 1);
        }
    }
    // Soil visible inside pot (thin strip just below rim)
    ctx.fillStyle = PALETTES.pot.soil;
    for (let row = 0; row < s(1); row++) {
        const soilHw = halfTop - s(1);
        for (let dx = -soilHw; dx < soilHw; dx++) {
            ctx.fillRect(Math.round(cx + dx), yTop + row, 1, 1);
        }
    }
    // Rim (on top of everything)
    for (let ry = 0; ry < rimH; ry++) {
        ctx.fillStyle = ry === 0 ? PALETTES.pot.rim : PALETTES.pot.main;
        for (let dx = -rimW; dx < rimW; dx++) {
            ctx.fillRect(Math.round(cx + dx), yTop - ry, 1, 1);
        }
    }
}

// --- VRSTVA 2: STONEK (Cylindrical shading, internode system) ---
function drawStem(ctx, rng, phenotype, data, windForceInt) {
    const startX = CTX_WIDTH / 2;
    const startY = CTX_HEIGHT - s(16);
    const endY = s(28);
    const isVine = phenotype.stem === 'vine';
    const isThick = phenotype.stemThickness === 'thick';
    const isHairy = phenotype.stemTexture === 'hairy';
    const palette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;

    const curveFreq = rng.float(0.03, 0.06);
    const curveAmp = isVine ? rng.range(s(6), s(10)) : rng.range(s(1), s(3));
    const phase = rng.float(0, Math.PI * 2);
    const nodeCount = rng.range(4, 7);  // Count - NOT scaled
    const nodeInterval = (startY - endY) / nodeCount;
    const baseHalf = isThick ? s(4) : s(2);
    const tipHalf = isThick ? s(2) : s(1);
    const maxWindSway = isVine ? s(2) : s(1);

    // Pre-calculate node positions
    const nodeYs = [];
    for (let i = 1; i <= nodeCount; i++) nodeYs.push(Math.round(startY - i * nodeInterval));

    let currentX = startX, nextNodeIdx = 0;
    for (let y = startY; y >= endY; y--) {
        const progress = 1 - (y - endY) / (startY - endY);
        const wave = Math.sin((y * curveFreq) + phase);
        const currentAmp = isVine ? (curveAmp * Math.sqrt(progress)) : (curveAmp * progress);
        const windOffset = Math.round(windForceInt * maxWindSway * progress);
        const x = startX + (wave * currentAmp) + windOffset;
        const halfWidth = Math.round(baseHalf + (tipHalf - baseHalf) * progress);
        const isNearNode = nodeYs.some(ny => Math.abs(ny - y) <= 1);
        const hw = isNearNode ? halfWidth + 1 : halfWidth;

        for (let dx = -hw; dx <= hw; dx++) {
            const nx = hw > 0 ? dx / hw : 0;
            const dot = -nx * LIGHT_DIR.x;
            const d = (Math.abs(Math.round(x + dx)) + Math.abs(y)) % 2 === 0;
            let color;
            if (Math.abs(dx) === hw) color = palette.dark;
            else color = palette.main;
            ctx.fillStyle = color;
            ctx.fillRect(Math.round(x + dx), y, 1, 1);
        }

        if (isHairy && rng.bool(0.12)) {
            const hs = rng.bool(0.5) ? -1 : 1;
            for (let h = 1; h <= rng.range(2, 4); h++)
                drawPixel(ctx, x + (hw + h) * hs, y - h, palette.light);
        }

        if (nextNodeIdx < nodeYs.length && y <= nodeYs[nextNodeIdx]) {
            const prevX = startX + (Math.sin(((y + 1) * curveFreq) + phase) * currentAmp) + windOffset;
            data.stemNodes.push({ x, y, angle: Math.atan2(-1, x - prevX), halfWidth: hw });
            nextNodeIdx++;
        }
        currentX = x;
    }
    data.topX = currentX;
    data.topY = endY;
}

// --- VRSTVA 3: LISTY (Phyllotaxis + venation) ---
function drawLeaves(ctx, rng, phenotype, data, windForceInt) {
    const isWide = phenotype.leaf === 'wide';
    const isSerrated = phenotype.leafEdge === 'serrated';
    const palette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;

    let minLen, maxLen;
    if (phenotype.leafSize === 'small') { minLen = s(8); maxLen = s(12); }
    else if (phenotype.leafSize === 'large') { minLen = s(14); maxLen = s(20); }
    else { minLen = s(10); maxLen = s(15); }

    const nodeCount = data.stemNodes.length;
    if (nodeCount < 2) return;

    // (c) Fixed 3-4 leaves, evenly spaced
    const leafCount = nodeCount >= 6 ? 4 : 3;

    // (a) Avoid top 45% of stem (flower zone) and bottom 10%
    const usable = data.stemNodes
        .map((node, i) => ({ node, i }))
        .filter(({ i }) => { const hr = i / nodeCount; return hr >= 0.1 && hr <= 0.55; });
    if (usable.length === 0) return;

    const step = Math.max(1, Math.floor(usable.length / leafCount));
    const picked = [];
    for (let k = 0; k < leafCount && k * step < usable.length; k++)
        picked.push(usable[k * step]);

    picked.forEach(({ node }, idx) => {
        // (b) Clean alternating sides, roughly horizontal with slight droop
        const side = (idx % 2 === 0) ? 1 : -1;
        const droop = rng.float(0.08, 0.35);
        const jitter = rng.float(-0.1, 0.1);
        const windRot = windForceInt * 0.04;
        const leafAngle = (side > 0)
            ? droop + jitter + windRot          // right, slightly down
            : Math.PI - droop + jitter + windRot; // left, slightly down

        const len = rng.range(minLen, maxLen);
        const width = isWide ? rng.range(s(5), s(8)) : rng.range(s(3), s(5));

        // Petiole (leaf stalk)
        const petLen = Math.round(len * 0.2);
        const petEndX = node.x + Math.cos(leafAngle) * petLen;
        const petEndY = node.y + Math.sin(leafAngle) * petLen;
        drawLine(ctx, node.x, node.y, petEndX, petEndY, palette.dark);

        // Leaf blade (shaded)
        const bladeCx = petEndX + Math.cos(leafAngle) * (len / 2);
        const bladeCy = petEndY + Math.sin(leafAngle) * (len / 2);
        drawShadedEllipse(ctx, bladeCx, bladeCy, len / 2, width / 2, leafAngle, palette, { isSerrated });

        // Central vein (midrib)
        const tipX = petEndX + Math.cos(leafAngle) * len;
        const tipY = petEndY + Math.sin(leafAngle) * len;
        drawLine(ctx, petEndX, petEndY, tipX, tipY, palette.dark);

        // Side veins
        const veinCount = Math.max(2, Math.floor(len / s(5)));
        for (let v = 1; v <= veinCount; v++) {
            const t = v / (veinCount + 1);
            const vbx = petEndX + Math.cos(leafAngle) * (len * t);
            const vby = petEndY + Math.sin(leafAngle) * (len * t);
            const vLen = (width / 2) * (1 - Math.abs(t - 0.5) * 1.5) * 0.7;
            for (const vs of [-1, 1]) {
                const vAngle = leafAngle + vs * (Math.PI / 3.5);
                drawLine(ctx, vbx, vby, vbx + Math.cos(vAngle) * vLen, vby + Math.sin(vAngle) * vLen,
                    palette.shadow || palette.dark);
            }
        }
    });
}

function drawTendrils(ctx, rng, phenotype, data) {
    const palette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;
    data.stemNodes.forEach((node, index) => {
        if (rng.bool(0.65)) {
            const side = (index % 2 === 0) ? 1 : -1;
            let tx = node.x, ty = node.y;
            const length = rng.range(s(5), s(10));
            let angle = (side === 1) ? 0 : Math.PI;
            for (let i = 0; i < length; i++) {
                tx += Math.cos(angle); ty += Math.sin(angle);
                angle += (side * 0.6);
                ctx.fillStyle = i / length < 0.3 ? palette.main : palette.light;
                ctx.fillRect(Math.round(tx), Math.round(ty), 1, 1);
            }
            // Coil at tip
            for (let i = 0; i < s(3); i++) {
                tx += Math.cos(angle) * 0.8; ty += Math.sin(angle) * 0.8;
                angle += (side * 1.2);
                ctx.fillStyle = palette.light;
                ctx.fillRect(Math.round(tx), Math.round(ty), 1, 1);
            }
        }
    });
}

function drawThorns(ctx, rng, data) {
    data.stemNodes.forEach((node, index) => {
        const side = (index % 2 === 0) ? 1 : -1;
        const angle = node.angle + (side * Math.PI / 2);
        const len = rng.range(s(3), s(5));
        const tipX = node.x + Math.cos(angle) * len;
        const tipY = node.y + Math.sin(angle) * len;
        drawLine(ctx, node.x, node.y, tipX, tipY, PALETTES.thorns.main);
        drawLine(ctx, node.x, node.y + 1,
            node.x + Math.cos(angle) * (len * 0.6), node.y + 1 + Math.sin(angle) * (len * 0.6),
            PALETTES.thorns.dark);
        drawPixel(ctx, node.x + Math.cos(angle) * 2, node.y + Math.sin(angle) * 2 - 1, PALETTES.thorns.highlight);
    });
}

function drawFruits(ctx, rng, phenotype, data) {
    const fruitPalette = rng.pick(PALETTES.fruits);
    const stemPalette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;
    const isOval = phenotype.fruitShape === 'oval';

    data.stemNodes.forEach(node => {
        if (rng.bool(0.55)) {
            const r = rng.range(s(2), s(4));
            const offsetX = rng.pick([-s(5), s(5)]);
            const offsetY = rng.range(s(1), s(5));
            drawLine(ctx, node.x, node.y, node.x + offsetX * 0.6, node.y + offsetY * 0.7, stemPalette.dark);
            const fx = node.x + offsetX, fy = node.y + offsetY + s(1);
            if (isOval) drawShadedEllipse(ctx, fx, fy, r, Math.round(r * 1.4), 0, fruitPalette);
            else drawShadedCircle(ctx, fx, fy, r, fruitPalette);
            drawPixel(ctx, fx - 1, fy - 1, fruitPalette.highlight);
        }
    });
}

// --- VRSTVA 6: KVƒöT (Sepals + shaded petals + detailed center) ---
function drawFlower(ctx, rng, phenotype, data, windForceInt) {
    const cx = data.topX, cy = data.topY;
    const isPointy = phenotype.flowerShape === 'pointy';
    let flowerScale = 0.7;
    if (phenotype.flowerSize === 'small') flowerScale = 0.5;
    if (phenotype.flowerSize === 'large') flowerScale = 1.0;

    const petalCount = rng.range(5, 8); // Count NOT scaled
    const petalLen = Math.round(rng.range(s(8), s(14)) * flowerScale);
    const petalWidth = Math.round(rng.range(s(4), s(7)) * flowerScale);
    const rotOff = rng.float(0, Math.PI) + (windForceInt * 0.04);

    // Petals
    for (let i = 0; i < petalCount; i++) {
        const angle = rotOff + (i / petalCount) * Math.PI * 2;
        const px = cx + Math.cos(angle) * (petalLen / 1.5);
        const py = cy + Math.sin(angle) * (petalLen / 1.5);
        const colorKey = (i % 2 === 0) ? phenotype.flowerColor : phenotype.flowerColorSecondary;
        const pColor = PALETTES.flowers[colorKey];
        const pattern = phenotype.flowerPattern;
        const patternColor = pColor.highlight || pColor.light;
        if (isPointy) drawShadedRhombus(ctx, px, py, petalLen, petalWidth, angle, pColor, { pattern, patternColor });
        else drawShadedEllipse(ctx, px, py, petalLen, petalWidth, angle, pColor, { pattern, patternColor });
        drawPixel(ctx, cx + Math.cos(angle) * s(2), cy + Math.sin(angle) * s(2), pColor.shadow || pColor.dark);
    }

    // Center
    const centerR = Math.max(s(3), Math.round(s(3) * flowerScale));
    if (phenotype.sex !== 'male') {
        const cp = phenotype.flowerColor === 'yellow'
            ? { highlight: '#ffcc80', light: '#fb8c00', main: '#ef6c00', dark: '#e65100' }
            : { highlight: '#fffde7', light: '#fff9c4', main: '#fdd835', dark: '#f9a825' };
        drawShadedCircle(ctx, cx, cy, centerR, cp);
        drawPixel(ctx, cx, cy - 1, cp.dark);
        drawPixel(ctx, cx, cy, '#5d4037');
    } else {
        drawShadedCircle(ctx, cx, cy, Math.max(s(2), centerR - 2),
            { highlight: '#a1887f', light: '#8d6e63', main: '#6d4c41', dark: '#4e342e' });
    }

    // Stamens
    if (phenotype.sex !== 'female') {
        const stamenCount = rng.range(4, 7); // Count NOT scaled
        for (let i = 0; i < stamenCount; i++) {
            const angle = (i / stamenCount) * Math.PI * 2 + rotOff + (Math.PI / petalCount);
            const len = Math.round(rng.range(s(5), s(9)) * flowerScale);
            const sx = cx + Math.cos(angle) * len, sy = cy + Math.sin(angle) * len;
            drawLine(ctx, cx + Math.cos(angle) * (centerR + 1), cy + Math.sin(angle) * (centerR + 1),
                sx, sy, PALETTES.stamens.stem);
            drawShadedCircle(ctx, sx, sy, Math.max(1, s(1)),
                { highlight: '#ffcc80', light: PALETTES.stamens.tipLight, main: PALETTES.stamens.tip, dark: '#e65100' });
        }
    }
}

function drawGlow(ctx, rng, data) {
    const colors = PALETTES.glow;
    for (let i = 0; i < rng.range(12, 20); i++) {
        const angle = rng.float(0, Math.PI * 2);
        const dist = rng.range(s(6), s(16));
        const x = Math.round(data.topX + Math.cos(angle) * dist);
        const y = Math.round(data.topY + Math.sin(angle) * dist);
        if (x > 0 && x < CTX_WIDTH && y > 0 && y < CTX_HEIGHT) {
            ctx.fillStyle = rng.pick([colors.bright, colors.mid, colors.dim]);
            ctx.fillRect(x, y, 1, 1);
            if (rng.bool(0.3)) { ctx.fillRect(x + 1, y, 1, 1); ctx.fillRect(x, y + 1, 1, 1); }
        }
    }
    data.stemNodes.forEach(node => {
        if (rng.bool(0.45)) {
            const gx = Math.round(node.x + rng.pick([-1, 1]) * rng.range(s(3), s(7)));
            const gy = Math.round(node.y + rng.range(-s(3), s(3)));
            if (gx > 0 && gx < CTX_WIDTH && gy > 0 && gy < CTX_HEIGHT) {
                ctx.fillStyle = rng.pick([colors.bright, colors.mid, colors.dim]);
                ctx.fillRect(gx, gy, 1, 1);
            }
        }
    });
}

/**
 * === UI HANDLING ===
 */

function getConfiguration() {
    return {
        phenotype: {
            stem: document.getElementById('gene-stem').value,
            stemThickness: document.getElementById('gene-stem-thickness').value, 
            stemTexture: document.getElementById('gene-stem-texture').value,     
            leaf: document.getElementById('gene-leaf').value,
            leafSize: document.getElementById('gene-leaf-size').value,
            leafEdge: document.getElementById('gene-leaf-edge').value,           
            foliageColor: document.getElementById('gene-foliage-color').value,
            flowerColor: document.getElementById('gene-color').value,
            flowerColorSecondary: document.getElementById('gene-color-2').value,
            flowerShape: document.getElementById('gene-flower-shape').value,
            flowerSize: document.getElementById('gene-flower-size').value,       
            flowerPattern: document.getElementById('gene-flower-pattern').value, 
            sex: document.getElementById('gene-sex').value,
            fruitShape: document.getElementById('gene-fruit-shape').value,       
            thorns: document.getElementById('gene-thorns').checked,
            fruit: document.getElementById('gene-fruit').checked,
            glow: document.getElementById('gene-glow').checked
        },
        seed: document.getElementById('input-seed').value,
        animate: document.getElementById('animate-toggle').checked
    };
}

// Animation loop handling
let animInterval = null;
let currentFrame = 0;

function startAnimation() {
    if (animInterval) clearInterval(animInterval);
    // ZMƒöNA: Zpomaleno z 200ms na 400ms pro klidnƒõj≈°√≠ "idle" tempo
    animInterval = setInterval(() => {
        currentFrame = (currentFrame + 1) % 4; // 0, 1, 0, -1
        update(true); // true = called from animation loop
    }, 400);
}

function stopAnimation() {
    if (animInterval) {
        clearInterval(animInterval);
        animInterval = null;
    }
    currentFrame = 0;
    update(false);
}

function update(isLoop = false) {
    const config = getConfiguration();
    
    // Logic for animation toggle
    if (config.animate && !animInterval && !isLoop) {
        startAnimation();
        return; // startAnimation will call update
    } else if (!config.animate && animInterval) {
        stopAnimation();
        return; // stopAnimation will call update
    }

    const canvas = document.getElementById('plantCanvas');
    const time = generatePlant(canvas, config.phenotype, config.seed, currentFrame);
    
    document.getElementById('seed-display').innerText = `Seed: ${config.seed}`;
    document.getElementById('time-display').innerText = `Render: ${time}ms | Frame: ${currentFrame}`;
}

document.getElementById('btn-generate').addEventListener('click', () => update(false));
document.getElementById('btn-random-seed').addEventListener('click', () => {
    document.getElementById('input-seed').value = Math.random().toString(36).substring(7);
    update(false);
});

// Vyhneme se dvoj√≠mu renderu: change pro select/checkbox, input jen pro text.
document.querySelectorAll('select, input[type="checkbox"]').forEach(input => {
    input.addEventListener('change', () => update(false));
});
document.querySelectorAll('input[type="text"]').forEach(input => {
    input.addEventListener('input', () => update(false));
});

async function copyTextToClipboard(text) {
    if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return;
    }

    const helper = document.createElement('textarea');
    helper.value = text;
    helper.setAttribute('readonly', '');
    helper.style.position = 'absolute';
    helper.style.left = '-9999px';
    document.body.appendChild(helper);
    helper.select();

    const copied = document.execCommand('copy');
    document.body.removeChild(helper);

    if (!copied) {
        throw new Error('Clipboard copy failed');
    }
}

document.getElementById('btn-export').addEventListener('click', async () => {
    try {
        await copyTextToClipboard(JSON.stringify(getConfiguration()));
        alert("Seed karta (JSON) zkop√≠rov√°na do schr√°nky!");
    } catch (error) {
        console.error('Nepoda≈ôilo se zkop√≠rovat seed kartu:', error);
        alert("Kop√≠rov√°n√≠ selhalo. Zkus str√°nku otev≈ô√≠t p≈ôes HTTPS nebo pou≈æij ruƒçn√≠ kopii.");
    }
});

const canvasElement = document.getElementById('plantCanvas');
canvasElement.width = CTX_WIDTH;
canvasElement.height = CTX_HEIGHT;

update();

</script>
</body>
</html>
