<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedur치ln칤 Gener치tor Rostlin (Pixel Art)</title>
    <style>
        :root {
            --bg-color: #1a1a1d;
            --panel-bg: #2d2d35;
            --text-color: #e0e0e0;
            --accent: #4caf50;
            --border: #444;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Layout */
        .container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }

        .controls {
            flex: 1;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            overflow-y: auto;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .preview-area {
            flex: 2;
            background: #111;
            border-radius: 8px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* UI Elements */
        h2, h3 { margin-top: 0; color: var(--accent); }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }

        label { font-size: 0.9em; color: #aaa; }
        
        select, input[type="text"] {
            background: #222;
            border: 1px solid #555;
            color: white;
            padding: 8px;
            border-radius: 4px;
        }

        input[type="checkbox"] {
            transform: scale(1.2);
            accent-color: var(--accent);
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        button:hover { opacity: 0.9; }
        button.secondary { background: #555; }

        /* Canvas rendering */
        canvas {
            image-rendering: pixelated; /* Kl칤캜ov칠 pro ostr칳 pixel art */
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            background: transparent;
        }

        .canvas-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .meta-info {
            font-family: monospace;
            color: #888;
            font-size: 0.8em;
            margin-top: 10px;
            text-align: center;
        }

        #seed-display {
            font-family: monospace;
            background: #000;
            padding: 5px 10px;
            border-radius: 4px;
            color: var(--accent);
        }

    </style>
</head>
<body>

<div class="container">
    <!-- Ovl치dac칤 panel (Fenotyp + Seed) -->
    <div class="controls">
        <h2>Laborato콏</h2>
        
        <div class="control-group">
            <label for="input-seed">Seed (콎et캩zec nebo 캜칤slo)</label>
            <div style="display:flex; gap:5px;">
                <input type="text" id="input-seed" value="rostlina1" style="flex:1">
                <button class="secondary" id="btn-random-seed">游</button>
            </div>
        </div>

        <h3>Genotyp (Fenotyp)</h3>
        
        <div class="control-group">
            <label>Stonek: Tvar / Tlou코콘ka / Povrch</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-stem" style="flex:1">
                    <option value="straight">Rovn칳</option>
                    <option value="vine">Li치na</option>
                </select>
                <select id="gene-stem-thickness" style="flex:1">
                    <option value="thin">Tenk칳</option>
                    <option value="thick">Tlust칳</option>
                </select>
                <select id="gene-stem-texture" style="flex:1">
                    <option value="smooth">Hladk칳</option>
                    <option value="hairy">Chlupat칳</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>Listy: Tvar / Velikost / Okraj</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-leaf" style="flex:1">
                    <option value="narrow">칔zk칠</option>
                    <option value="wide">말rok칠</option>
                </select>
                <select id="gene-leaf-size" style="flex:1">
                    <option value="small">Mal칠</option>
                    <option value="medium" selected>St콏edn칤</option>
                    <option value="large">Velk칠</option>
                </select>
            </div>
             <select id="gene-leaf-edge" style="margin-top:5px;">
                <option value="smooth">Hladk칳 okraj</option>
                <option value="serrated">Zoubkovan칳 (Pilovit칳)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="gene-foliage-color">Barva rostliny (Foliage)</label>
            <select id="gene-foliage-color">
                <option value="green">Zelen치 (Green)</option>
                <option value="teal">Siv치/Modr치 (Teal)</option>
                <option value="autumn">Podzimn칤 (Autumn)</option>
                <option value="dark">Tmav치 (Dark)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Kv캩t: Tvar / Velikost / Vzor</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-flower-shape" style="flex:1">
                    <option value="round">Obl칠</option>
                    <option value="pointy">맗i캜at칠</option>
                </select>
                <select id="gene-flower-size" style="flex:1">
                    <option value="small">Mal칳</option>
                    <option value="medium" selected>St콏edn칤</option>
                    <option value="large">Velk칳</option>
                </select>
            </div>
            <select id="gene-flower-pattern" style="margin-top:5px;">
                <option value="plain">Bez vzoru</option>
                <option value="stripes">Pruhy</option>
                <option value="dots">Te캜ky</option>
            </select>
        </div>

        <div class="control-group">
            <label>Barvy kv캩tu (Prim치rn칤 / Sekund치rn칤)</label>
            <div style="display:flex; gap:5px;">
                <select id="gene-color" style="flex:1">
                    <option value="red">캛erven치</option>
                    <option value="blue">Modr치</option>
                    <option value="purple">Fialov치</option>
                    <option value="white">B칤l치</option>
                    <option value="yellow">콯lut치</option>
                </select>
                <select id="gene-color-2" style="flex:1">
                    <option value="red">캛erven치</option>
                    <option value="blue">Modr치</option>
                    <option value="purple">Fialov치</option>
                    <option value="white">B칤l치</option>
                    <option value="yellow">콯lut치</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label for="gene-sex">Pohlav칤 kv캩tu</label>
            <select id="gene-sex">
                <option value="hermaphrodite">Hermafrodit (Pest칤k + Ty캜inky)</option>
                <option value="female">Sami캜칤 (Jen Pest칤k)</option>
                <option value="male">Sam캜칤 (Jen Ty캜inky)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="gene-fruit-shape">Tvar plodu</label>
            <select id="gene-fruit-shape">
                <option value="round">Kulat칳</option>
                <option value="oval">Ov치ln칳</option>
            </select>
        </div>

        <div class="control-group">
            <label class="checkbox-row" style="margin-bottom: 5px;">
                <input type="checkbox" id="animate-toggle">
                <span style="color: var(--accent); font-weight:bold;">Animace (Idle)</span>
            </label>
        </div>

        <div class="checkbox-row">
            <label class="checkbox-row" style="flex:1">
                <input type="checkbox" id="gene-thorns">
                <span>Trnit칠</span>
            </label>
             <label class="checkbox-row" style="flex:1">
                <input type="checkbox" id="gene-fruit">
                <span>Plod칤c칤</span>
            </label>
        </div>

        <div class="control-group">
            <label class="checkbox-row">
                <input type="checkbox" id="gene-glow">
                <span>Bioluminiscence (Glow)</span>
            </label>
        </div>

        <button id="btn-generate">Generovat Rostlinu</button>
        <button id="btn-export" class="secondary">Kop칤rovat Seed Kartu</button>
    </div>

    <!-- V칳hledov치 plocha -->
    <div class="preview-area">
        <div class="canvas-container">
            <!-- Canvas 64x96 -->
            <canvas id="plantCanvas" width="64" height="96" style="width: 320px; height: 480px;"></canvas>
            <div class="meta-info">
                <span id="seed-display">Seed: --</span><br>
                <span id="time-display">Render: 0ms | Frame: 0</span>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * === PALETY A KONSTANTY ===
 */
const PALETTES = {
    // Varianty barev pro stonek a listy
    foliage: {
        green: { light: '#8bc34a', main: '#558b2f', dark: '#33691e' },
        teal:  { light: '#80cbc4', main: '#00897b', dark: '#004d40' },
        autumn: { light: '#ffcc80', main: '#ef6c00', dark: '#e65100' }, // Do rezava
        dark:  { light: '#90a4ae', main: '#455a64', dark: '#263238' }  // Tmav캩 코edomodr치
    },
    pot: { light: '#d7ccc8', main: '#8d6e63', dark: '#5d4037', soil: '#3e2723' },
    thorns: { main: '#3e2723', light: '#5d4037' }, // Tmav치
    // Pole mo쬹칳ch barev plod콢 - vyb칤r치 se podle seedu
    fruits: [
        { light: '#ff8a65', main: '#d84315', dark: '#bf360c' }, // Oran쬺v치
        { light: '#ba68c8', main: '#8e24aa', dark: '#4a148c' }, // Fialov치
        { light: '#ef5350', main: '#c62828', dark: '#b71c1c' }, // 캛erven치
        { light: '#4fc3f7', main: '#039be5', dark: '#01579b' }  // Modr치 (fantasy)
    ],
    flowers: {
        red: { light: '#ff8a80', main: '#d32f2f', dark: '#b71c1c' },
        blue: { light: '#82b1ff', main: '#2979ff', dark: '#0d47a1' },
        purple: { light: '#ea80fc', main: '#aa00ff', dark: '#4a148c' },
        white: { light: '#ffffff', main: '#e0e0e0', dark: '#9e9e9e' },
        yellow: { light: '#ffffbf', main: '#fdd835', dark: '#f9a825' } 
    },
    stamens: { stem: '#fff59d', tip: '#f57f17' },
    glow: '#ccff90' // Neon
};

/**
 * === PRNG (Pseudo-Random Number Generator) ===
 */
class Random {
    constructor(seedStr) {
        // Hashov치n칤 stringu na 캜칤slo
        let h = 2166136261 >>> 0;
        for (let i = 0; i < seedStr.length; i++) {
            h = Math.imul(h ^ seedStr.charCodeAt(i), 16777619);
        }
        this.state = h;
    }

    // Vrac칤 float 0.0 a 1.0
    next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }

    // Vrac칤 integer min (v캜etn캩) a max (v캜etn캩)
    range(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
    
    // Vrac칤 float min a max
    float(min, max) {
        return this.next() * (max - min) + min;
    }

    // Pravda/Nepravda s pravd캩podobnost칤 p
    bool(p = 0.5) {
        return this.next() < p;
    }
    
    // N치hodn치 volba z pole
    pick(array) {
        return array[Math.floor(this.next() * array.length)];
    }
}

/**
 * === DRAWING ENGINE (Pixel Art) ===
 */
const CTX_WIDTH = 64;
const CTX_HEIGHT = 96;

function drawPixel(ctx, x, y, color) {
    ctx.fillStyle = color;
    // ZAOKROUHLEN칈: Pro pixel-perfect animaci mus칤me pozice zaokrouhlovat na cel치 캜칤sla,
    // jinak by canvas d캩lal sub-pixel rendering (rozmaz치n칤).
    ctx.fillRect(Math.round(x), Math.round(y), 1, 1);
}

// Bresenham콢v algoritmus pro pixel-perfect 캜치ru
function drawLine(ctx, x0, y0, x1, y1, color) {
    x0 = Math.round(x0); y0 = Math.round(y0);
    x1 = Math.round(x1); y1 = Math.round(y1);
    
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = (x0 < x1) ? 1 : -1;
    const sy = (y0 < y1) ? 1 : -1;
    let err = dx - dy;

    ctx.fillStyle = color;

    while (true) {
        ctx.fillRect(x0, y0, 1, 1);
        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x0 += sx; }
        if (e2 < dx) { err += dx; y0 += sy; }
    }
}

// Vypln캩n칳 kruh (pixelated)
function drawCircle(ctx, xc, yc, r, color) {
    xc = Math.round(xc); yc = Math.round(yc); r = Math.floor(r);
    ctx.fillStyle = color;
    for (let y = -r; y <= r; y++) {
        for (let x = -r; x <= r; x++) {
            if (x*x + y*y <= r*r) {
                ctx.fillRect(xc + x, yc + y, 1, 1);
            }
        }
    }
}

// Vypln캩n치 elipsa s podporou zoubkov치n칤 (Serrated)
function drawEllipseRotated(ctx, xc, yc, rx, ry, angle, color, isSerrated = false, pattern = 'plain', patternColor = null) {
    const maxR = Math.max(rx, ry);
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    
    ctx.fillStyle = color;

    // Iterujeme p콏es bounding box
    for (let x = -maxR; x <= maxR; x++) {
        for (let y = -maxR; y <= maxR; y++) {
            // Rotace bodu zp캩t do lok치ln칤ho syst칠mu elipsy
            const dx = x * cosA + y * sinA;
            const dy = y * cosA - x * sinA;
            
            // Z치kladn칤 rovnice elipsy
            let dist = (dx*dx)/(rx*rx) + (dy*dy)/(ry*ry);

            // Zoubkov치n칤 (Serration) logic
            if (isSerrated) {
                // 칔hel v r치mci elipsy
                const theta = Math.atan2(dy, dx);
                // Modulace polom캩ru sinusovkou (d캩l치 zuby)
                const serration = 1.0 - 0.25 * Math.abs(Math.sin(theta * 5)); // 5 zub콢 na stranu
                // Pokud je bod uvnit콏 "zubat칠" hranice
                if (dist <= serration) {
                    drawPixelWithPattern(ctx, xc+x, yc+y, color, pattern, patternColor, x, y);
                }
            } else {
                // Hladk칳 okraj
                if (dist <= 1) {
                    drawPixelWithPattern(ctx, xc+x, yc+y, color, pattern, patternColor, x, y);
                }
            }
        }
    }
}

// Vypln캩n칳 koso캜tverec (pro 코pi캜at칠 l칤stky)
function drawRhombusRotated(ctx, xc, yc, rx, ry, angle, color, pattern = 'plain', patternColor = null) {
    const maxR = Math.max(rx, ry);
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    
    ctx.fillStyle = color;

    for (let x = -maxR; x <= maxR; x++) {
        for (let y = -maxR; y <= maxR; y++) {
            const dx = x * cosA + y * sinA;
            const dy = y * cosA - x * sinA;
            
            if (Math.abs(dx/rx) + Math.abs(dy/ry) <= 1) {
                drawPixelWithPattern(ctx, xc+x, yc+y, color, pattern, patternColor, x, y);
            }
        }
    }
}

// Pomocn치 funkce pro vzory na l칤stc칤ch
function drawPixelWithPattern(ctx, x, y, baseColor, pattern, patternColor, localX, localY) {
    let finalColor = baseColor;

    if (pattern === 'stripes') {
        // Pruhy ka쬯칠 2 pixely
        if (Math.abs(localX) % 3 === 0) finalColor = patternColor;
    } else if (pattern === 'dots') {
        // Te캜ky (코achovnice nebo n치hodn캩ji)
        if ((localX*localX + localY*localY) % 7 === 0) finalColor = patternColor;
    }

    ctx.fillStyle = finalColor;
    ctx.fillRect(Math.round(x), Math.round(y), 1, 1);
}

/**
 * === LOGIKA GENER츼TORU ===
 */

function generatePlant(canvas, phenotype, seedStr, frame = 0) {
    const startTime = performance.now();
    const ctx = canvas.getContext('2d');
    
    // 1. Reset
    ctx.clearRect(0, 0, CTX_WIDTH, CTX_HEIGHT);
    
    // Glob치ln칤 data rostliny pro layers
    const plantData = {
        stemNodes: [], // {x, y, angle}
        topX: 0,
        topY: 0
    };

    // V칗PO캛ET V캨TRU (PIXEL-ART ANIMACE)
    // M칤sto float sinusovky pou쮂셨치me celo캜칤seln칳 lookup table (LUT).
    // Sekvence 4 sn칤mk콢: St콏ed(0) -> Vpravo(1) -> St콏ed(0) -> Vlevo(-1).
    // To vytv치콏칤 jemn칠, "zubat칠" pohupov치n칤 bez interpolace.
    const windPattern = [0, 1, 0, -1];
    const windForceInt = windPattern[frame % 4]; 

    // --- VRSTVA 1: KV캨TIN츼캛 (Statick칳) ---
    drawPot(ctx, new Random(seedStr + "_pot"));

    // --- VRSTVA 2: STONEK ---
    drawStem(ctx, new Random(seedStr + "_stem"), phenotype, plantData, windForceInt);

    // --- VRSTVA 2.5: 칔PONKY ---
    if (phenotype.stem === 'vine') {
         drawTendrils(ctx, new Random(seedStr + "_tendrils"), phenotype, plantData);
    }

    // --- VRSTVA 3: LISTY ---
    drawLeaves(ctx, new Random(seedStr + "_leaves"), phenotype, plantData, windForceInt);

    // --- VRSTVA 4: TRNY ---
    if (phenotype.thorns) {
        drawThorns(ctx, new Random(seedStr + "_thorns"), plantData);
    }

    // --- VRSTVA 5: PLODY ---
    if (phenotype.fruit) {
        drawFruits(ctx, new Random(seedStr + "_fruit"), phenotype, plantData);
    }

    // --- VRSTVA 6: KV캨T ---
    drawFlower(ctx, new Random(seedStr + "_flower"), phenotype, plantData, windForceInt);

    // --- VRSTVA 7: GLOW ---
    if (phenotype.glow) {
        drawGlow(ctx, new Random(seedStr + "_glow"), plantData);
    }

    const endTime = performance.now();
    return (endTime - startTime).toFixed(2);
}

// --- Implementace vrstev ---

function drawPot(ctx, rng) {
    const cx = CTX_WIDTH / 2;
    const yBottom = CTX_HEIGHT - 2;
    const yTop = CTX_HEIGHT - 10;
    const widthTop = 14;
    const widthBottom = 10;

    ctx.fillStyle = PALETTES.pot.main;
    const halfTop = widthTop / 2;
    const halfBot = widthBottom / 2;
    
    const steps = yBottom - yTop;
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const currentWidth = halfTop - (t * (halfTop - halfBot));
        const y = yTop + i;
        ctx.fillRect(Math.round(cx - currentWidth), y, Math.round(currentWidth * 2), 1);
    }

    drawLine(ctx, cx + halfBot - 1, yBottom, cx + halfTop - 1, yTop, PALETTES.pot.dark);
    
    ctx.fillStyle = PALETTES.pot.dark;
    ctx.fillRect(Math.round(cx - halfTop - 1), yTop - 1, widthTop + 2, 2);
    
    drawEllipseRotated(ctx, cx, yTop, halfTop - 1, 2, 0, PALETTES.pot.soil);
}

function drawStem(ctx, rng, phenotype, data, windForceInt) {
    const startX = CTX_WIDTH / 2;
    const startY = CTX_HEIGHT - 14; 
    const endY = 20; 
    
    let currentX = startX;
    const isVine = phenotype.stem === 'vine';
    const isThick = phenotype.stemThickness === 'thick';
    const isHairy = phenotype.stemTexture === 'hairy';

    const palette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;
    
    const curveFreq = rng.float(0.1, 0.2); 
    const curveAmp = isVine ? rng.range(6, 12) : rng.range(1, 3); 
    const phase = rng.float(0, Math.PI * 2);
    
    const nodeCount = rng.range(3, 5);
    const nodeInterval = (startY - endY) / nodeCount;
    let nextNodeY = startY - nodeInterval;

    // Wind efekt: max v칳chylka naho콏e (1px pro normal, 2px pro vine)
    // T칤mto zajist칤me, 쬰 pohyb je opravdu jen o 1-2 pixely, velmi subtiln칤.
    const maxWindSway = isVine ? 2 : 1; 

    for (let y = startY; y >= endY; y--) {
        const progress = 1 - (y - endY) / (startY - endY); // 0 dole, 1 naho콏e
        const wave = Math.sin((y * curveFreq) + phase);
        const currentAmp = isVine ? (curveAmp * Math.sqrt(progress)) : (curveAmp * progress);
        
        // Aplikace v캩tru: Line치rn칤 n치r콢st s v칳코kou a zaokrouhlen칤 pro pixel skok
        // windForceInt je -1, 0, nebo 1.
        const windOffset = Math.round(windForceInt * maxWindSway * progress); 

        const x = startX + (wave * currentAmp) + windOffset;
        
        // Kreslen칤 stonku podle tlou코콘ky
        if (isThick) {
            drawPixel(ctx, x - 2, y, palette.dark);
            drawPixel(ctx, x - 1, y, palette.dark);
            drawPixel(ctx, x, y, palette.main);
            drawPixel(ctx, x + 1, y, palette.main);
            drawPixel(ctx, x + 2, y, palette.light);
        } else {
            drawPixel(ctx, x - 1, y, palette.dark);
            drawPixel(ctx, x, y, palette.main);
            drawPixel(ctx, x + 1, y, palette.light);
        }

        // Textura: Chlupat칳 stonek
        if (isHairy) {
            if (rng.bool(0.2)) drawPixel(ctx, x - (isThick ? 3 : 2), y, palette.light);
            if (rng.bool(0.2)) drawPixel(ctx, x + (isThick ? 3 : 2), y, palette.dark);
        }

        if (y <= nextNodeY && data.stemNodes.length < nodeCount) {
            // U uzl콢 tak칠 aplikujeme windOffset, aby listy neplavaly mimo stonek
            const prevX = startX + (Math.sin(((y+1) * curveFreq) + phase) * currentAmp) + windOffset;
            const dx = x - prevX;
            const angle = Math.atan2(dx, -1); 
            data.stemNodes.push({ x: x, y: y, angle: angle });
            nextNodeY -= nodeInterval;
        }
        currentX = x;
    }
    data.topX = currentX;
    data.topY = endY;
}

function drawLeaves(ctx, rng, phenotype, data, windForceInt) {
    const isWide = phenotype.leaf === 'wide';
    const isSerrated = phenotype.leafEdge === 'serrated';
    const palette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;

    let minLen, maxLen;
    if (phenotype.leafSize === 'small') { minLen = 4; maxLen = 6; } 
    else if (phenotype.leafSize === 'large') { minLen = 9; maxLen = 14; } 
    else { minLen = 6; maxLen = 10; }

    data.stemNodes.forEach((node, index) => {
        const side = (index % 2 === 0) ? -1 : 1;
        const stemNormal = node.angle + (side * (Math.PI / 2.5));
        
        // Listy se tak칠 m칤rn캩 nat치캜ej칤 ve v캩tru, ale jen o mal칳 kousek
        const windRotation = windForceInt * 0.05; 
        const leafAngle = stemNormal + rng.float(-0.2, 0.2) + windRotation;

        const len = rng.range(minLen, maxLen);
        const width = isWide ? rng.range(4, 5) : rng.range(2, 3);

        const cx = node.x + (Math.cos(leafAngle) * (len/2));
        const cy = node.y + (Math.sin(leafAngle) * (len/2));

        drawEllipseRotated(ctx, cx, cy, len/2, width/2, leafAngle, palette.main, isSerrated);
        
        const tx = node.x + (Math.cos(leafAngle) * len);
        const ty = node.y + (Math.sin(leafAngle) * len);
        drawLine(ctx, node.x, node.y, tx, ty, palette.dark);
    });
}

function drawTendrils(ctx, rng, phenotype, data) {
    const palette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;
    data.stemNodes.forEach((node, index) => {
        if (rng.bool(0.7)) { 
             const side = (index % 2 === 0) ? 1 : -1; 
             let tx = node.x;
             let ty = node.y;
             const length = rng.range(5, 8);
             ctx.fillStyle = palette.light; 
             let angle = (side === 1) ? 0 : Math.PI;
             for(let i=0; i<length; i++) {
                 tx += Math.cos(angle);
                 ty += Math.sin(angle); 
                 angle += (side * 0.8); 
                 ctx.fillRect(Math.round(tx), Math.round(ty), 1, 1);
             }
        }
    });
}

function drawThorns(ctx, rng, data) {
    data.stemNodes.forEach((node, index) => {
        const side = (index % 2 === 0) ? 1 : -1; 
        const angle = node.angle + (side * Math.PI/2);
        const len = rng.range(2, 4);
        const tipX = node.x + Math.cos(angle) * len;
        const tipY = node.y + Math.sin(angle) * len;
        drawLine(ctx, node.x, node.y, tipX, tipY, PALETTES.thorns.main);
    });
}

function drawFruits(ctx, rng, phenotype, data) {
    const fruitPalette = rng.pick(PALETTES.fruits);
    const stemPalette = PALETTES.foliage[phenotype.foliageColor] || PALETTES.foliage.green;
    const isOval = phenotype.fruitShape === 'oval';

    data.stemNodes.forEach(node => {
        if (rng.bool(0.6)) { 
            const r = rng.range(2, 3);
            const offsetX = rng.pick([-4, 4]); 
            const offsetY = rng.range(0, 4);   

            drawLine(ctx, node.x, node.y, node.x + offsetX/2, node.y + offsetY, stemPalette.dark);
            
            const fx = node.x + offsetX;
            const fy = node.y + offsetY + 1;
            
            if (isOval) {
                drawEllipseRotated(ctx, fx, fy, r, r * 1.5, 0, fruitPalette.main);
            } else {
                drawCircle(ctx, fx, fy, r, fruitPalette.main);
            }
            
            drawPixel(ctx, fx+1, fy+1, fruitPalette.dark);
            drawPixel(ctx, fx-1, fy-1, fruitPalette.light);
        }
    });
}

function drawFlower(ctx, rng, phenotype, data, windForceInt) {
    const cx = data.topX;
    const cy = data.topY;
    const isPointy = phenotype.flowerShape === 'pointy';
    
    let scale = 1.0;
    if (phenotype.flowerSize === 'small') scale = 0.7;
    if (phenotype.flowerSize === 'large') scale = 1.3;

    const petalCount = rng.range(5, 8);
    const petalLen = rng.range(4, 7) * scale;
    const petalWidth = rng.range(2, 4) * scale;
    // Jemn치 rotace
    const rotationOffset = rng.float(0, Math.PI) + (windForceInt * 0.05); 

    for (let i = 0; i < petalCount; i++) {
        const angle = rotationOffset + (i / petalCount) * Math.PI * 2;
        const px = cx + Math.cos(angle) * (petalLen/1.5);
        const py = cy + Math.sin(angle) * (petalLen/1.5);

        const colorKey = (i % 2 === 0) ? phenotype.flowerColor : phenotype.flowerColorSecondary;
        const pColor = PALETTES.flowers[colorKey];
        
        const pattern = phenotype.flowerPattern; 
        const patternColor = pColor.light; 

        if (isPointy) {
            drawRhombusRotated(ctx, px, py, petalLen, petalWidth, angle, pColor.main, pattern, patternColor);
        } else {
            drawEllipseRotated(ctx, px, py, petalLen, petalWidth, angle, pColor.main, false, pattern, patternColor);
        }
        
        const basePx = cx + Math.cos(angle) * 1;
        const basePy = cy + Math.sin(angle) * 1;
        drawPixel(ctx, basePx, basePy, pColor.dark);
    }

    if (phenotype.sex !== 'male') {
        const centerColor = (phenotype.flowerColor === 'yellow') ? '#fb8c00' : '#fff59d';
        const centerDark = (phenotype.flowerColor === 'yellow') ? '#e65100' : '#fbc02d';
        drawCircle(ctx, cx, cy, 2, centerColor); 
        drawPixel(ctx, cx, cy, centerDark); 
    } else {
        drawCircle(ctx, cx, cy, 1, '#8d6e63');
    }

    if (phenotype.sex !== 'female') {
        const stamenCount = rng.range(3, 6);
        const stamenStemColor = (phenotype.flowerColor === 'yellow') ? '#e65100' : PALETTES.stamens.stem;
        for (let i = 0; i < stamenCount; i++) {
            const angle = (i / stamenCount) * Math.PI * 2 + rotationOffset + (Math.PI/petalCount); 
            const len = rng.range(3, 6);
            const sx = cx + Math.cos(angle) * len;
            const sy = cy + Math.sin(angle) * len;
            drawPixel(ctx, cx + Math.cos(angle)*(len/2), cy + Math.sin(angle)*(len/2), stamenStemColor);
            drawPixel(ctx, sx, sy, PALETTES.stamens.tip);
        }
    }
}

function drawGlow(ctx, rng, data) {
    const flowerParticles = rng.range(8, 12); 
    for(let i=0; i<flowerParticles; i++) {
        const angle = rng.float(0, Math.PI * 2);
        const dist = rng.range(6, 14); 
        const x = data.topX + Math.cos(angle) * dist;
        const y = data.topY + Math.sin(angle) * dist;
        
        if(x > 0 && x < CTX_WIDTH && y > 0 && y < CTX_HEIGHT) {
            ctx.fillStyle = PALETTES.glow;
            ctx.fillRect(Math.round(x), Math.round(y), 1, 1);
        }
    }
    data.stemNodes.forEach(node => {
        if(rng.bool(0.4)) { 
             const ox = rng.pick([-1, 1]) * rng.range(3, 6);
             const oy = rng.range(-3, 3);
             const gx = Math.round(node.x + ox);
             const gy = Math.round(node.y + oy);
             if(gx > 0 && gx < CTX_WIDTH) {
                 ctx.fillStyle = PALETTES.glow;
                 ctx.fillRect(gx, gy, 1, 1);
             }
        }
    });
}

/**
 * === UI HANDLING ===
 */

function getConfiguration() {
    return {
        phenotype: {
            stem: document.getElementById('gene-stem').value,
            stemThickness: document.getElementById('gene-stem-thickness').value, 
            stemTexture: document.getElementById('gene-stem-texture').value,     
            leaf: document.getElementById('gene-leaf').value,
            leafSize: document.getElementById('gene-leaf-size').value,
            leafEdge: document.getElementById('gene-leaf-edge').value,           
            foliageColor: document.getElementById('gene-foliage-color').value,
            flowerColor: document.getElementById('gene-color').value,
            flowerColorSecondary: document.getElementById('gene-color-2').value,
            flowerShape: document.getElementById('gene-flower-shape').value,
            flowerSize: document.getElementById('gene-flower-size').value,       
            flowerPattern: document.getElementById('gene-flower-pattern').value, 
            sex: document.getElementById('gene-sex').value,
            fruitShape: document.getElementById('gene-fruit-shape').value,       
            thorns: document.getElementById('gene-thorns').checked,
            fruit: document.getElementById('gene-fruit').checked,
            glow: document.getElementById('gene-glow').checked
        },
        seed: document.getElementById('input-seed').value,
        animate: document.getElementById('animate-toggle').checked
    };
}

// Animation loop handling
let animInterval = null;
let currentFrame = 0;

function startAnimation() {
    if (animInterval) clearInterval(animInterval);
    // ZM캨NA: Zpomaleno z 200ms na 400ms pro klidn캩j코칤 "idle" tempo
    animInterval = setInterval(() => {
        currentFrame = (currentFrame + 1) % 4; // 0, 1, 0, -1
        update(true); // true = called from animation loop
    }, 400);
}

function stopAnimation() {
    if (animInterval) {
        clearInterval(animInterval);
        animInterval = null;
    }
    currentFrame = 0;
    update(false);
}

function update(isLoop = false) {
    const config = getConfiguration();
    
    // Logic for animation toggle
    if (config.animate && !animInterval && !isLoop) {
        startAnimation();
        return; // startAnimation will call update
    } else if (!config.animate && animInterval) {
        stopAnimation();
        return; // stopAnimation will call update
    }

    const canvas = document.getElementById('plantCanvas');
    const time = generatePlant(canvas, config.phenotype, config.seed, currentFrame);
    
    document.getElementById('seed-display').innerText = `Seed: ${config.seed}`;
    document.getElementById('time-display').innerText = `Render: ${time}ms | Frame: ${currentFrame}`;
}

document.getElementById('btn-generate').addEventListener('click', () => update(false));
document.getElementById('btn-random-seed').addEventListener('click', () => {
    document.getElementById('input-seed').value = Math.random().toString(36).substring(7);
    update(false);
});

// Vyhneme se dvoj칤mu renderu: change pro select/checkbox, input jen pro text.
document.querySelectorAll('select, input[type="checkbox"]').forEach(input => {
    input.addEventListener('change', () => update(false));
});
document.querySelectorAll('input[type="text"]').forEach(input => {
    input.addEventListener('input', () => update(false));
});

async function copyTextToClipboard(text) {
    if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return;
    }

    const helper = document.createElement('textarea');
    helper.value = text;
    helper.setAttribute('readonly', '');
    helper.style.position = 'absolute';
    helper.style.left = '-9999px';
    document.body.appendChild(helper);
    helper.select();

    const copied = document.execCommand('copy');
    document.body.removeChild(helper);

    if (!copied) {
        throw new Error('Clipboard copy failed');
    }
}

document.getElementById('btn-export').addEventListener('click', async () => {
    try {
        await copyTextToClipboard(JSON.stringify(getConfiguration()));
        alert("Seed karta (JSON) zkop칤rov치na do schr치nky!");
    } catch (error) {
        console.error('Nepoda콏ilo se zkop칤rovat seed kartu:', error);
        alert("Kop칤rov치n칤 selhalo. Zkus str치nku otev콏칤t p콏es HTTPS nebo pou쬴j ru캜n칤 kopii.");
    }
});

update();

</script>
</body>
</html>
